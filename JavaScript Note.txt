
I. VARIABLE			VIII. CONDITION			XV. CANVAS
				  *SWITCH		  	 
				  *TERNARY OPERATOR
			  
II. MATH			IX. ERROR			XVI. TEST DRIVEN DEVELOPMENT (TDD)
  *FUNCTION
  *ROUND NUMBER
III. OBJECT			X. GLOBAL			XVII. REGULAR EXPRESSION
  *ARRAY
  *DESTRUCTURING
  *ASSIGNMENT
  *FREQUENT METHOD
  
IV. METHOD			XI. LOOP  	
*AUDIO/VIDEO METHOD		  *RECURSION
V. CLASS OBJECT			XII. TYPE
VI. FUNCTION			XIII. EVENT
  *INFINITE ARGUEMENT 		  *HTML EVENTS
  *FUNC DECLARATION		  *KEYCODE
  *ARROW FUNCTION
VII. STRING			XIV. JAVASCRIPT DOM
				  *HTML DOM
				  *DOM METHOD
				  *DOM DOCUMENT
				  *DOM NAVIGATION
				  *DOM NODES
				  *NODELIST
				  *DOM WINDOWS


*OPERATOR
- new operator: 	+ create an empty object
		+ set "this" to point to that object
		+ return object from function
	

- ?? (nullist coalescing operator): short syntax selecting "define" variable from list
	E.g: a ?? b
		value = a if a is not null/ undefined
		value = b otherwise
	let firstName = null;
	let lastName = null;
	let nickName = "Supercoder";
	alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // => Supercoder

- ? (question mark operator): ternary operator
- Dataset: object contain data attribute from specific element
	<HTML>	<p id="p" data-name ="paragraph" data-usage ="text"></p>
	<JavaScript> p = document.getElementById('p')
		     console.log(p.dataset)
- ! not operator: !variable: check if undefined/null - return false otherwise return true


COMMENT
- // in-line comment
- /* multi-line comment end with */

CLEAN CODE
-Indentation: consistent
-Semicolons: do it
-Line length: 80 characters, indent 2 lvl when breaking lines
-Name Things: camelCase, single character in loop/ callback function
-begin with: Noun for Variable
	     Verb for function
		


* DATA TYPE
- undefined	
- null
- boolean
- string
- symbol
- number
- object
- parseInt(str, a) - to convert into integer, str: input, a is number e.g 2 = binary
- toString(radix): convert number to string

*DATE OUTPUT
-new Date()
-new Date(year, month, day, hours, minutes, second, miliseconds) (all numerical: Jan = 0, Dec = 11)
-new Date(miliseconds)
-new Date(date string)

new Date()
.getDate():	returns day of month(1-31)
.getDay():	returns day of week (0-6)
.getFullYeaar():returns year
.getHours():	returns hour (0-23)
.getMilliseconds():
.getMinutes():	returns minutes(0-59)
.getMonth():	returns month (0-11)
.getSeconds():	returns seconds(0-59)
.getTime(): 
.getTimezoneOffset()
.getUTC Date/Day/FullYear/Houts/Milliseconds/Minutes/Month/Seconds()
.set ... similar to get



*CAPTURE PROPAGTION AND BUBBLING
- When you click an element:
+CAPTURE: click ripple from top element down capture all events
+BUBBLING: triggering event from bottom up
+Option  object :	
	E.g: divs.forEach(div => div.addEventListener('click', logText, {
		capture: true/false
	}	
	capture: true - run function on the way downdefault capture: false - 
	once: true 	-listen to click then unbind its self
- e.stopPropagation(): stop bubbling event up.



*ATTRIBUTE SELECTOR
- CSS attribute selector matches elements based on presence or value of given attribute
	+a[title]: <a> element with a 'title' attribute
	+a[href="https://..."]: <a> element with href matching "https://..." 
	+a[attr~=value]: "value" in list of words separated by space
	+a[attr|=value]: exact "value" / begin "value" followed by hypher used for
language subcode matches
	+a[attr^=value]: atribute value begin with "value"
	+a[arre*=value]: contain one occurrence of "value"
	+a[... i]: i before bracket ends, value case insensitive
	+a[... s]: s before bracket ends, value case sensitive



I. VARIABLE
- var ... = -use throughout program ('='  assign operator)
- let ... = -its scope is limited to the block statement or expression that it was declared in
	don't let you declare a variable twice 
- const ...= -cannot be changed or READ ONLY, use CAPITAL LETTER for ease of recognition
- define variable with no var automatically put it to global - meaning it can be use throught the program
- if var is use in a function its scope is in that function
- "use strict": indicate code should be executed in "strict mode"
strict mode: cannot use undeclared variable, prevent typing error that create another variable
- object.freeze(CONST VARIABLE) - to prevent const from being changed
- const s = [5,7,2] - const array changeable using bracket notation
	s[0] = 2;
	s[1] = 5;
	s[2] = 7; 
- destruction assignment used to assign object to  





II. MATH
- % - remainder operator
- ** - exponentiation

- increment number means add 1
	e.g: a= a+1; or a++;
- decrement number
	e.g: b = b-1; or b--;
- compound assignment: a += 1
- == convert both value to the same type
- === strict equality operator don't convert	
- && - and operator
- || - or operator						
- var r = Math.random();

*FUNCTION: MATH					
- .random(): 	random number between 0 and 1 without 1
- .round():	round to nearest integer
- .sqrt():	square root
- .abs(): 	abosolute
- .floor():	round down to nearest integer	
- .ceil():	round up to nearest integer
- .min():	
- .max():
- .pow(x,y):	return x to power of y

*ROUND NUMBER TO SPECIFIC DECIMAL
- Math.round(num * 10)/10;
- number.toFixed(n): converts number -> string, rounding to specified n number of decimals
	+ use .parseFloat(number.tofixed(n)): to convert back to number
- Rounding with precision function:
	function round(value, precision){
		var multiplier = Math.pow(10, precision || 0);
		return Math.round(value * multiplier) / multipler;
	}





III. OBJECT
- a data type, store complex entities + collection of various data types
- created using figure brackets {...} with list of properties
- A property = "key:value"	key/property name = string	value = anything
				
- use name indexes
- let name = 'Mosh' - assign variable

- let person = { 		- {} object literal
	name: 'Mosh',
	age: 30,
	"likes birds": true,	//"like birds" multiword srting must be quoted
	} 			/*last property can end with comma = trailing/ hanging comma
				make it easier to add/remove/move properties, all line alike */
- const user = {		/*object declare by const can be modified
	name: "John"		const fixes value of user not its cocntent.
};				error if user = ...*/
user.name = "Pete"; 
alert(user.name); 	=>Pete

*Dot Notation
- person.name = 'John';

+ Bracket Notation: 	+good for dynamically access a property name
			+property names that are not valid name identifiers
			- [] required when object property has space/ special characters

- Computed properties: square bracket in object literal when creating object
	E.g:	let fruit = promt("which fruit to buy?", "apple")
		let bag ={
			[fruit]:5, // the name taken from fruit variable
		};
		alert(bag.apple); // 5 if fruit ="apple"
	more complex expression inside square bracket:
		let fruit = 'apple';
		let bag ={
			[fruit + "Computers"]:5 //bag.appleComputers = 5
		};

- Property value shorthand:
	function makeUser(name,age){
		return{
			name, 	//same as name:name
			age,	//same as age:age
			//...other properties
	}};
- property name can be anything even language-reserved words like "for", "let",etc
- Other type: converted to string when using as property name
	let obj = {
		0: "test" // same as "0": "test"
	};
- __proto__: special property, can't set it to non-object value
	let obj ={};
	obj.__proto__= 5; // assign a number
	alert(obj.__proto__); //[object Object] - the value is an object

- "in" operator: used test whether property exists, if no return "undefined"
left side of "in" must be property name to be tested, variable must be property name
"in" work well with property that store "undefined"

	let user = {name: "John", age: 30, "test": undefined);
	let key = "age";
	alert("age" in user); 		//true, user.age exists
	alert("blable" in user); 	//false, user.blabla doesn't exist
	alert(key in user); 		//true, age exist

- "for...in" loop: to iterate all keys of object
	let user = {
		name: "John",
		age: 30,
		isAdmin: true,
	};

	for (let key in user){
		//keys
		alert(key); // name, age, isAdmin
		//values for keys
		alert(user[key]); // John, 30, true		
 
- Object is "ordered in a special fashion": interger properties are sorted, 
other appear in creation order. for integer appear in creation folder add special character


- person['name'] = 'Mary'; - let selection = 'name';
	person[selection] = 'Mary';

- add property to object
	person.shirt = 'T-shirt';
	person['shoes'] = 'Nike;
- delete property
	delete person.shirt;



*ARRAY
- use numbered indexes
- [] - Array literal = list
- [['abc', 2], ['efg',1],...] - nested array or multi-dimensional array
- Access multi-dimesional array with bracket notation
	E.g: var myArray = [[],[],[],...]; var myData = myArray[0][0];

- new operator can be used to create array
	E.g: var cars = new Array('Saab', 'Volvo', 'BMW');

- new/ ...Array() constructor: create array object
	+new Array(element0, element1, ..., elementN): array is initialized with those elements
	+new Array(arraylength): if arraylength = interger between 0 and (2^32)-1 return array with length
	set to that number

- Array.from() or ... (spread operator): convert element into array

*DESTRUCTURING ASSIGNMENT
- make it possible unpack values arrays/ object properties -> distinct variables
- E.g:
	let a,b;
	[a,b[ = [1,2];
	console.log(a);	// 1
	console.log(b); // 2
- Default value
	let a,b;
	[a=5, b=7] = [1];
	console.log(a); // 1
	console.log(b); // 7
- Swapping variables:
	const arr = [1,2,3];
	[arr[2], arr[1]] = [arr[1], arr[2]];
	console.log(arr); // [1,3,2]
- Parsing an array returned from a function, ignoring some returned values

	function f() {
	  return [1, 2, 3];
	}
	let a, b;
	[a, , b] = f();
	
	[,,] = f(); 	//ignore all returned values
	console.log(a); // 1
	console.log(b); // 3

- Assign the rest of array to a variable
	let [a, ...b] = [1, 2, 3];
	console.log(a); // 1
	console.log(b); // [2, 3];

- Unpacking values from a regular expression match(search when needed);

- Object destructuring:
	const user = {
		id: 42,
		is_verified: true
	};
	const (id, is_verified) = user

+assign new variable names + default value
	const (id: p = 30, name: q = false) = user;
	console.log(p); // 30
	console.log(q); // false
	
+unpacking fields from objects passed as a function parameter
	const user = {
	  id: 42,
	  displayName: 'jdoe',
	  fullName: {
		firstName: 'John',
		lastName: 'Doe'
	  }
	};
	function userId({id}) {
	  return id;
	}
	
	function whoIs({displayName, fullName: {firstName: name}}){
	  return `${displayName} is ${name}`;
	
	console.log(userId(user)); //42
	console.log(whoIs(user));  //'jdoe is John'

+setting a function parameter's default value
	funtion drawChart ({size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}){
	  console.log(size, coords, radius);
	  //do some chart drawing
	}
	drawChart({
	  coords: {x: 18, y:30},
	  radius: 30
	});
	
+Nested object and array destructuring
	const metadata = {
	  title: 'Scratchpad',
	  translations: [
     	    {
		title: 'JavaScript-Umgebund'
	    }
	  ]};

	let {
	  title: englishTitle, // rename
	  translation: [
	    {
		title: localeTitle, 	//rename
	    },
	  ]} = metadata;

	console.log(englishTitle);	//'Scratchpad'
	console.log(localeTitle);	//'JavaScript-Umgebung'

+For of iteration and destructuring
+computed object property names and destructuring
	let key = 'z';
	let {[key]: foo} = {z:'bar'};
	console.log( foo); // "bar"
+Rest in object destructuring
	let {a,b, ...rest} = {a:10, b:20, c:30, d:40}
	a; // 10
	b; // 20
	rest; //{c:30, d:40}
+Combined Array and Object destructuring
	const props = [
	  {id: 1, name: 'Fizz'},
	  {id: 2, name: 'Buzz'},
	  {id: 3, name: 'FizzBuzz'}
	];
	const [,,{ name }] = props;
	console.log(name); //"FizzBuzz"



*FREQUENTLY USED ARRAY METHOD:
- toString() + join(): join array elements into a string
	join can specifies separatorq
		e.g .join('*')
- .push():append data to the end of an array and return new array length

- .pop(): remove last item in an array and return that item

- .shift(): remove first item in an array and return it, shift other elements to lower index

- .unshift(item1, item2,..., itemN): add element to the beginning of the array and returns new length

- .delete could be used to delete elements but leaves holes use pop/ shift instead

- .length: # of elements
	also can be use to append: fruits[fruits.length] = "Kiwi"

- .splice(startIndex, deleteCount): change array content, remove/ replace (mutating) 
	
	+var planet = ['Mars', ' Saturn', 'Pluto', Earth']
	+remove item: 	planet.splice(2,1)  //remove 2nd index item and 1 item
	+add item:	planet.splice(1,0, 'Pluto', 'Uranus')  //add item if delete count = 0
	+planet.splice(1) = ['Mars']

- .concat(): merge arrays together
	var A = ['a', 'b', 'c']
	var B = ['d', 'e']
	A.concat(B) -> A = ['a', 'b', 'c', 'd', 'e']

- .slice(start, end): return selected elements in a new array object
	+include start  but not end elements

- .sort(compareFunction): sort elements alphabetically and ascending by default	
	+incorrect when sorting number
	+numeric sort: Ascending
		var points = [40, 100, 1, 5, 25, 10];
		points.sort(function(a, b){return a-b});		
			-> 1, 5, 10, 25, 40, 100
	+numeric sort: Descending
		{return(b-a)}
	+compare function: sort() function compares two values. sort values 
			according to the returned (+/-/0) value
	negative(-) a is sorted before b
	positive(+) b is sorted before a
		(0) no changes
	+ Random sort order: {return 0.5 - Math.random()}

- Math.max.apply on array to find highest number
	function myArrayMax(arr){
		return Math.max.apply(null, arr);

- Math.min.apply to find the lowest number in an array
	function myArrayMin(arr) {
		return Math.min.apply(null, arr);
	}

- .split(separator, limit): split string into array of substring, return new arrays
	sepearator: specify character/expression used for splitting if left empty entire
			string returned( an array with 1 item), ("") used as separator, split between character
	limit: interger specifies number of splits, items after limit not in array
		E.g: const 
		
			
IV. Method
- .constructor: returns constructor function for object
	+arrays: return function Array(){[native code]}
	+numbers: returns function Number(){[native code]}
	+strings: returns function String(){[native code]}

- .copyWithin(target, start, end): copies elements to another position, overwrite existing value
				never add more items to array
	+ target(required): index position to copy to
	+ start: index position start copy from 
	+ end: index position stop copy from

- .entries(): returns array iterator object with key/value pairs
	[0, "banana"]
	[1, "orange"]
	[2, "apple"]

- .every(function(currentValue, index, arr), thisValue): checks if all elements in an array pass a test
	return boolean		

- .fill(value, start, end): fill specified elements with static value 	
	fruits = ["banana", "orange", "apple", "mango"]
	fruits.fill("Kiwi",2,4);

- .filter(function(currentValue[, index, arr]]), thisValue): creates array filled elements pass test

  E.g:	var ages = [32, 33, 16, 40];
 	function checkAdult(age) {
  		return age >= 18;
	}
	function myFunction() {
  	document.getElementById("demo").innerHTML = ages.filter(checkAdult);
	}

	//JavaScript30 Array
	const fifteen = inventors.filter(function(inventors){
	if (invetors.year >= 1500 && inventors.year <= 1600){
		return true;
	}});
	

- .find(function(currentValue, index, arr), thisValue): returns value 1st element pass a test
	E.G: 
	array1 = [5, 12, 8, 130, 44];
	const found = array1.find(element => element >10);
	console.log(found);
	

- .findIndex(function(currentValue, index, arr), thisValue): execute function once each element
	+if function returns True, return index element( and does not check remaining value)
	+otherwise return -1

- .forEach(function(currentValue, index, arr), thisValue): calls function each element in order
		
- .from(object, mapFuntion, thisValue): return array object from any object with lenghth property or iterable object
	+Object: object to convert to array
	+mapFunction: map function call each item
	+thisValue: value use when execute mapFunction
	
	+ Array from set:
	const set = new Set(['foo', 'bar', 'baz', 'foo']);
	Array.from(set);
	// [ "foo", "bar", "baz" ]
	
	
	
- .includes(element, start): determines whether array contains specified element,
	return true or false, case sensitive

- .indexOf(item, start): find specified item returns its position 
	+From start to end
	+more than once, returns position of 1st occurence
	+return -1 if not found

- .join(separator): returns array as string
	seperator: default comma (,)

- .keys(): returns array iterator object with keys

- .length: returns number of elements

- .lastIndexOf(item, start): search for specified item, returns position
	+Start at the end
	+more than once returns last occurence
	+returns -1 if not found

- .map(function(currentValue, index, arr), thisValue): creates new array with results 
after executing function
	+calls function once for each element in order
		var numbers = [4, 9, 16, 25];
		var x = numbers.map(Math.sqrt)
		-> 2,3,4,5
		var x = numbers.map(x => x) //clone original array
		-> [4, 9, 16, 25] 

- .prototype: constructor allows new properties + method be added to Array() object
	+Constructing property: all arrays given the property + its value as default
	+Constructing method: all arrays have this method available
		Array.prototype.myUcase = function() {
  			for (i = 0; i < this.length; i++) {
    				this[i] = this[i].toUpperCase();
  			}
		};



- .reduce( function (total, currentValue[ currentIndex[, arr]]){
	//return result from executing something for accumulator or currentValue	
	}, initialValue): 
+ total(required): initial value/ previously return value of function
+ currentValue(required): value of current element
+ currentIndex(optional): array index of current elements
+ arr(optional): array object current element belongs to
+ initialValue(optional): if not provided, total = 1st array element, 
currentValue = second element

	+reduce array to a single value 
	+does not change original array
	+execute function for array with values only, for each value left to right
		
		const array1 = [1, 2, 3, 4];
		const reducer = (accumulator, currentValue) => accumulator + currentValue
		console.log(array1.reduce(reducer));
		//expected output: 10
	
	+Sum up instances of array elements(Javascript30)  
		const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 
		'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck']
		const transportation = data.reduce(function(obj, item) {
			if(!obj[item[){
			  obj[item] = 0;
			}
			obj[item]++;
		}, {});
		
	+sum of values in an object array
		sum = [{x:1}, {x:2},{x:3}].reduce(
		(total, current) =>total + current.x
		, 0
		)
		console.log(sum) // 6
	+flatten array of arrays
		let flattened = [[0,1], [2,3], [4,5]].reduce(
		  (sum, value) => sum.concat(value)}
		, []
		)
		//flattened is [0, 1, 2, 3, 4, 5]
	+Counting instances of values in an object
		let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']
		let countedNames = names.reduce(function(allNames, name){
		  if (name in allNames){
			allNames[name]++;
		  }else{
			allNames[name] = 1;
		  }
		  return allNames
		}, {})
		//countedNames is {'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1)

	+Grouping objects by property
		let people = [
		  {name: 'Alice', age: 21},
		  {name: 'Max', age: 20},
		  {name: 'Jane', age: 20}
		];

		function groupBy(objectArray, property){
		  return objectArray.reduce(function(acc, obj){
			let key = obj[property]
			if (!acc[key]) {
			  acc[key] = [];
			}
			acc[key].push(obj)
			return acc
		}, {})
		let groupedPeople = groupby(people, 'age')
		// groupPeople is 
		{
		  20: [
			{name: 'Max', age: 20},
			{nameL 'Jame', age: 20)
		  ]
		  21: [{name: 'Alice', age: 21}]
		}
	+remove duplicate from array
	+replace .filter().map() with .reduce()
	+write map using reduce

- reduceRight((function(total, currentValue, currentIndex, arr), initialValue):
	+reduce array single value
	+execute function from right to left
	+return value as accumlator	 

- .reverse(): reverse order elements




- .some (function(currentValue[, index, [arr]]), thisValue): 
	+check logic of elements, return true
	+used on [] => false
	E.g: const array = [1, 2, 3, 4, 5];
	     const even = (element) => element % 2 ===0;

	     console.log(array.some(even));
		=> true. 


- .toString(): returns string with all array values, separated by commas



- .valueOf(): returns array



- .forEach (value, index, object): get array with values -> apply logic to them
	calls callback function once each elements array decesnd order
	E.g:	-itemArray.forEach (puppy => puppy + 2)	

- .appendchild: append elements to an existing elements
	const grid = document.querySelector('.grid')
	var square = document.creatElement('DIV')

	grid.appendchild (square)

- .setInterval(function, milisecond, param1, param2,...)
	function: that will be executed
	milisecond: interval on how often to execute the code
	param1, param2: additional parameter to pass function

- apply(thisArg, [argsArray}): method takes array as argument
- call(): method takes arguments sepatately
	var person = {
		fullName:function(city, country){
			return this.firstName + " " + this.lastName + "," + city + "," + country;
		}
	var Person1 = {
		firstName: "John",
		lastName: "Doe"
	}
+	person.fullname.apply(person1, ["Olso", "Norway"]
+	person.fullname.call(person1, "Olso", "Norway")

- Application of apply
	- Math.max.apply on array to find highest number
		function myArrayMax(arr){
			return Math.max.apply(null, arr);

	- Math.min.apply to find the lowest number in an array
		function myArrayMin(arr) {
			return Math.min.apply(null, arr);
	- first argument [null] doesn't matter
		or	       Math.min.apply(Math, arr)
		or 	       Math.min.apply(0, arr)
		or	       Math.max.apply(" ", arr);


- keys(): return Array Iterator object contains keys for each index in array



*AUDIO/VIDEO METHOD
- addTextTrack():	Adds a new text track to the audio/video
- canPlayType() 	Checks if the browser can play specific audio/video type
- load()		re-loads the audio/video element
- play() 		starts playing the audio/video
- pause()		pauses currently playing audio/video




V. CLASS OBJECT
- CONSTRUCTOR: defined capitalized name 
use keyword "this" set properties of object created
	function Constructor() {
		this.name = "";
		this.age = ;
	}
	E.g: function Bird (){
	    	this.name = "swan";
		this.color = "white";
		this.numLegs = 2
	     }	


	+ OWN PROPERTY: name, color and numLegs are own properties. every instance
of Bird have its own copy of its properties. defined directly on object instance itself

	E.g: add own property of duck to array ownProps 
	let ownProps = [];
	for (let property in duck){
	  if(duck.hasOwnProperty(property)){
	    ownProps.push(property)
	  }
	}
		

	+ Give constructor parameter for easier adding/ editing large amount of data
	
	E.g: function Bird(name, color){
	   this.name = name;
	   this.color = color;
	   this.numLegs = 2;
	}
	=> let cardinal = new Bird("Bruce", "red");


	+ PROTOTYPE PROPERTY: all instances of object share property, defined on prototype

	E.g: Add numLegs to Bird prototype 
	let duck = new Bird("Donald");
	let canary = new Bird("Tweety");
	Bird.prototype.numLegs = 2
	-> now all instances of Bird has "numLegs" property
	  duck and carnary part Bird constructor as Bird.prototype. 
	  Nearly every object in JavaScript has prototype property part of constructor
	function created it


	E.g: add duck's own properties to ownProps array and prototype properties 
to prototypeProps:
	function Dog(name) {
	  this.name = name;
	}
	let ownProps = [];
	let prototypeProps = [];
	for (let property in duck){
	  if (duck.hasOwnProperty(property)){
	    ownProps.push(property);
	  } else {
	    prototypeProps.push(property);
	  }
	}


	+ CONSTRUCTOR PROPERTY ( object.constructor ): reference constructor function of instance. Possible check what kind object. 
	Can be easily overwritten, generally better to use “instanceof” method to check type
	   
	E.g: check a property what kind object
	function joinDogFraternity(candidate){
	  if (candidate.constructor === Dog) {
 	    return true;
	  } else {
	    return false;
	  }
	}


	ADDING MULTIPLE PROPERTIES TO PROTOTYPE: side effect: overwrite constructor property. Remember to set constructor proterty when changing prototype
	E.g: 
	Dog.prototype = {
	  constructor: Dog,
	  numLegs: 4,
	  eat: function(){
	    console.log("nom nom nom");
	  },
	  describe: function(){
	    console.log("My name is " + this.name);
	  }
	};

- CLOSURE: 
prevent modification properties externally
 +Add variable in constructor func -> changes scope of variable within constructor
instead global
	E.g: function Bird(){
		let hatchedEgg = 10; //private variable
	//publicly available method bird object can use
		this.getHatchedEggCount = function(){
		  return hatchedEgg;
		};
	     }
	     let ducky = new Bird();
	     ducky.getHatchedEggCount(); // return 10
	getHatchedEggCount: priviledge method
	


- All objects have prototype, prototype itself object
-> prototype has own prototype.
	E.g: prototype of Bird.prototype is Object.prototype



- Accessing JavaScript Properties:
	objectName.property	// person.age
OR	objecName["property"]	// person["age"]
OR	objectName[epxression]	// x = "age"; person[x]





* INHERITANCE
-DRY - don't repeat yourself: 
	subtypes has same methods
	use supertype to remove these methods
	Bird.prototype = {
	  constructor: Bird,
	  describe: function(){
	    console.log("My name is " + this.name);
	  }
	};

	Dog.prototype = {
	  constructor: Dog,
	  describe: function(){
	    console.log("My name is" + this.name);
	  }
	}

	+Use supertype(or parent) Animal to DRY:
	function Animal() {};
	
	Animal.prototype = {
	  constructor: Animal,
	  describe: function() {
	    console.log("My name is " + this.name);
	  }
	}
	

- Inherit behaviors from  Supertype
	let animal = Object.create(Animal.prototype);
	Object.create(obj): create new object, sets obj as new object's prototype
	
	E.g: reuse Animal's method inside duck and beagle
	function Animal(){
	  constructor: Animal,
	  eat: function(){
	    console.log("nom nom nom");
	  }
	};

	let duck = Object.create(Animal.prototype);
	let beagle = Object.create(Animal.prototype);


- Reset inherited constructor property: when object inherit prototype another object
also inherits supertype's constructor property
	E.g: 
	function Bird(){
	  Bird.prototype = Object.createAnimal.protoype);
	  let duck = new Bird();
	  duck.constructor  //function Animal(){...}  
	}

	Bird.prototype.constructor = Bird;
	duck.constructor  //function Bird(){...}


- Add methods after inheritance:	 
	E.g: Bird.prototype.fly = function(){
		console.log("I'm flying!");
	};

	Dog.prototype = Object.create(Animal.prototype);
	Dog.prototype.constructor = Dog;
	Dog.prototype.bark = function(){
	  console.log('Woof!')
	};

- Inherited methods can be override using:
	childObject.prototype.methodName = function(){...}
- When calling method JavaScript will look up the prototype chain till the method
is defined
	1. duck => Is eat() defined here? No
	2. Bird => 	    ''		? Yes. Execute and stop searching
	3. Animal => 	    '' 		? Yes but JS already stopped
	etc.

- Use mixin for unrelated object instead of inheritance, mixin allows other objects
use collection functions
	E.g: let flyMixin = function(obj){
	       obj.fly = function(){
		console.log("Flying, woosoh!");
	  }
	};

	flyMixin give objects fly method

	let bird = {			let plane = {
	  name: "Donald",		  model: "777",
	  numLegs: 2			  numPassengers: 524
	};				};
	
	flyMixin(bird);	//takes object gives it fly method
	bird.fly(); //prints "Flying, wooosh!"
	flyMixin(plane);	plane.fly(); // prints "Flying, wooosh!"



* PROTOTYPE: 
+ Prototype chain: Bird supertype duck, duck subtype. Object supertype all object
JavaScript. Any object can use hasOwnProperty() method.
hasOwnProperty() method defined Object.prototype

+ Declaring method on construtor, create it again on other instances,
declaring methods on prototype happens once since it shared
-> memory efficient


- class: ...
class Car {
 	  constructor(brand) {  // Constructor
    	     this.carname = brand;
  	  }
	}
	mycar = new Car("Ford");

- extend: create child class of parent class

	class Model extends Car {
  	    constructor(brand, mod) {
    		super(brand);
    		this.model = mod;
  	    }
  	    show() {
    		return this.present() + ', it is a ' + this.model;	
	    }
	}
	mycar = new Model("Ford", "Mustang");
	document.getElementById("demo").innerHTML = mycar.show();
		
	
- static keyword: define static methods of classes, called directly class (car)
without creating instance/object(mycar)

- super keyword: refers to parents class, calls constructor of parent class to access 
parent's properties and methods
	
- "new" keyword: instantiate / represent a new instance of an object 
obtain value from object and set its value to the newly created object
without "new", "this" inside the constructor would not point to newly created object



- getter function return object private varible 
	get: function(){
		return ...;
	}
- setter function: set value for property 
	set: function(value){
	
	}

*METHOD
 - instanceof(): check if an object creates using a constructor
	E.g: let crow = new Bird("Alexis", "black");
	     crow instanceof Bird; 
	     => true

- hasOwnProperty(): return boolean if object has specified property as own property
defined in Object.prototype, can be accessed by Bird.prototype
	
	E.g: obj.hasOwnProperty(prop)
		-prop: string/symbol test

- isPrototypeOf: check an object exists another object prototype chain

	E.g: constructor.prototype.isPrototypeOf(object);


*IMMIDIATELY INVOKED FUNCTION EXPRESSION(IIFE):
  - Execute function as soon as it declared
	E.g: (function () {
		console.log("Chirp, chirp!");
	     })();
	- no name, not stored in variable function
	Parentheses () at the end -> immediately executed/ invoked
	
  - Used to group related functionality -> single object/ module
	E.g:  Group glide and fly function from Mixin section
	      let motionModule = (function () {
		return {
		  glideMixin: function(obj) {
		    obj.glide = function () {
		      console.log("Gliding on the water");
		    };
		  },
		  flyMixin: function(obj) {
		    obj.fly = function() {
		      console.log("Flying, wooosh!")'
		    };
		  }
	        }
	     })();

	motionModule.glideMixin(duck);
	duck.glide();




VI. FUNCTION
- Funtion should be short only do one action according to its name, if that action is too big
split it into smaller ones
=> easier to test + debug

+Default parameter: - arguement/parameters is undefined
-default can be changed:
	function showMessage(text = "no text given"){
	Or	if (text === undefined){
		 
	Or	text = text || 'empty'	
	
	Or	text = 'empty message';

- e/evt/event parameter: represent element affected by event handler


*INFINITE ARGUMENT FUNCTION
- Arguments object (ES5): arguments local JS object variable available all non-arrow functions
array-like object accessible inside functions contains values of arguments passes to that function
not array	
	function add(){
		console.log(arguements);
		var sum = 0;
		for (var i = 0; i<arguments.length; i++){
			sum += arguments[i];
		}
		return sum;
	}
	console.log(add(3, 4, 7)); // 14
	console.log(add(3, 4, 7, 10, 20); // 44

- Rest operator (ES6):
	function add(...args){
		return args.reduce(function(acc, cur) {
			return acc+cur;
		})
	}
	console.log(add(3, 4, 7));  //14	
	console.log(add(3, 4, 7, 4)); // 18



*FUNCTION DECLARATION 
- Function declaration: default usage, better readability. easy to look up
	function a(){} - no semi colon at the end due to code blocks + syntax structures doesn't need 

- Function Expression: conditional declaration
	let a = function(){};
   E.g:
	let age = prompt("What is your age?", 18);

	let welcome = (age < 18) ?
	  function() { alert("Hello!"); } :
	  function() { alert("Greetings!"); };

	welcome();

- Find Max in an array function:
	function myArrayMax(arr){
		var len = arr.length;
		var max = -Infinity;
		while(len--){
			if(arr[len] > max)
				max = arr[len];
			}
		}return Max;
	}

- Find min in an array function:
	function myArrayMax(arr){
		var len = arr.length;
		var min = Infinity;
		while(len--){
			if(arr[len] < min)
				min = arr[len];
			}
		}return min;
	}


*ARROW FUNCTION	
- Arrow function: let func = (arg1, arg2, ... argN) => expression
	  let sum = (a, b) => a + b;
short for let sum = function(a, b){
	    return a + b;
	 };
   E.g:
	let age = prompt("What is your age?", 18);
	
	let welcome = (age < 18) ?
	  () => alert('Hello') :
	  () => alert("Greetings!");

	welcome();
Even shorter version than function expression

	//JavaScript30 Array
	const fifteen = inventors.filter(inventors => invetors.year >= 1500 && inventors.year <= 1600);


- Multiline arrow function: when more complex action is needed, use {} + normal return

	E.g:
	let sum = (a, b) => {  // the curly brace opens a multiline function
	  let result = a + b;
	  return result; // if we use curly braces, then we need an explicit "return"
	};
 



- isNaN: test if value a number, true: not number, false: it's number 



- var myConcat = function(arr1, arr2){  - Annonymous function doesn't have a name can be assign to variable
	return arr1.concat(arr2);  	- annonymous function can be converted into arrow function
  };
	
	var myConcat = (arr1, arr2) =>  arr1.concat(arr2) - arrow function used when a function takes another
	console.log(myConcat([1,2], [3, 4, 5]));	 function as an arguement


- const increment = (function(){
	return function increment(number, value = 1) {  //if value isn't pass in it is 1 automatically
	return number +value
	};
})();
  console.log(increment(5,2)); increment = 7
  console.log(increment(5));   increment = 6	

- ... - rest operator allow function that take a variable amount of arguement
- ... - spread operator: take an array and spread out into individual part 

- =>: arrow function, shorter syntax, return value by default
	hello = function(){			hello = (parameter) => 'hello world'
		return "hello world";			
	}

*FUNCTIONAL PROGRAMMING:
- Style of programming, simple isolated functions without 
side effects outside func scope
	INPUT -> PROCESS -> OUTPUT

- Functional programming is about
1. Isolated function: no dependence state program, includes global var subjected to change
2. Pure function - same input -> same output
3. Function with limited side effects - changes/ mutations to program state outside
function are carefully controlled
	Functional Programming Principle:
	- Avoid mutating variable/ object creates new variables + objects
	- Declare dependencies explicity = if function depends on variable/ object, pass
	it into as argument -> function easy testing, what input it takes, won't depend
	on anything else.


- Callbacks: function that are slipped/ passed into another function decide invocation
of that function
- First Class Function: can be assigned to variable + passed into another function
 + returned another function like normal value. All JS function are first class.





VII. STRING
- .length - return length of string
- .indexOf() - return position of the 1st occurence of specific text in a string
- .lastIndexOf() - return position of the last occurence of specific text in a string
- .charAt("".length-1): to find last character of a string
- index - return -1 if the text not found
- The search() method cannot take a second start position argument.
- The indexOf() method cannot take powerful search values (regular expressions).
- \n new line
- \t tap
- \b backspace
- \f form feed
- concatenating string with + operator: "a" + "b"; or var str = 'a'; str += 'b';

- str.charCodeAt(index): return interger between 0-65535 representing 
UTF-16 code unit

- fromCharCode(num1[, ...[, numN]]): return strings created from specified 
sequence UTF-16 code units
- charAt(index): 

+Template Literal - special type of string that make complex string easier
- `...` : back tick
- advantages: 	+ multi-line string
		+ add single and double quotation mark without escaping
		+ put variable into the string using ${}
	
- 


VIII. CONDITION
- if statement
- Ternary operator: condition ? statement-if-true: statement-if-false;
	return num > 0? "positive" : num < 0 ? "negative" : "zero" 






*CONDITIONAL (TERNARY) OPERATOR
	E.g:	var age = n;
		var voteble = (age < 18) |?| "Too Young" |:| "Old enough"; **
		alert(voteble);


*SWITCH
- E.g: SWITCH statement that will alert "hello" if fruits is "banana" and "welcome" if fruits is "apple", alert "neither" if fruits is neither "banana" nor "apple"
	+ Switch(fruits) {
		case "banana";
		  alert("hello")
		  break;
		case "apple";
		  alert("welcome");
		  break;
		default:
		  alert("neither);
	 }



IX. ERROR
- name:	+SyntaxError: syntax error
	+RangeError: a number 'out of range' has occured
	+ReferenceError: illegal reference occured
	+TypeError:
	+URIError: error in encodeURI()

- message: description of an error

- try statement lets you test a block of code for errors.
	try {
  	  adddlert("Welcome guest!");
	}
	catch(err) {
	  document.getElementById("demo").innerHTML = err.message;

- catch statement lets you handle the error.

- throw statement lets you create custom errors.
	throw "Too big";    // throw a text
	throw 500;          // throw a number
	
- finally statement lets you execute code, after try and catch, regardless of the result.

	var message, x;
  	message = document.getElementById("p01");
  	message.innerHTML = "";
  	x = document.getElementById("demo").value;
  	try {
    	   if(x == "") throw "is empty";
    	   if(isNaN(x)) throw "is not a number";
    	   x = Number(x);
      	   if(x > 10) throw "is too high";
    	   if(x < 5) throw "is too low";
  	}
  	catch(err) {
    	   message.innerHTML = "Error: " + err + ".";
  	}
  	finally {
    	   document.getElementById("demo").value = "";
	




X. GLOBAL
- Number()	Converts an object's value to a number
- parseFloat()	Parses a string and returns a floating point number
- parseInt()	Parses a string and returns an integer 
- String()	Converts an object's value to a string
	




XI. LOOP
- Name a loop: used to target break or continue
	+break out of targeted loop/ continue next iteration of nested loop
	+labelName: loop
- A single execution of the loop body is called an iteration.

- Loop features: a loop usually has one/ more
	+ Counter:initailized with value
	+ Condition: true/ false test to continue/ stop loop
	+ Iterator: increment counter small amount each successive loop -> condition = false
- for (initializer; condition; final-expression) - loops through a block of code a number of times


- break: exits/jump out switch statement or a loop and continue codes outside loop

- continue: continue/jump over next iteration of loop 
	+While loop, condition tested, true, loop excecuted again
	+for loop, increment expression (i++) 1st evaluated, condition is tested,
	find if another iteration should be done

- for/in - loops through the properties of an object (don't use array index order important)
	var person = {fname:"John", lname:"Doe", age:25};

	var text = "";
	var x;
	for (x in person) {
	  text += person[x] + " ";
	}
	-> John Doe 25

- for/of - loops through the values of an iterable object
	var cars = ['BMW', 'Volvo', 'Mini'];
	var x;
	
	for (x of cars) {
	  document.write(x + "<br >");
	}
	->BMW	
	  Volvo
	  Mini


- while - loops through a block of code while a specified condition is true
shorter way to write while (i != 0) is while (i):


- do/while - loops through a block of code once, and then repeats the loop while a specified condition is true

	
- Postfix and Prefix: + Prefix (++i): first increments i then return new value
	+Postfix (i++): increment i then returns old value


*RECURSION
- When function calls itself until it stops
- Can be used in place of loop
- Base case: condition stops recursion
- Loop usess extra state variables tracking + counting while recursion uses provided 
parameters.
- E.g:
	function CountDownFrom(number){
		if (number === 0) {
		  return;
		}
		console.log(nuber);
		counDownFrom(number - 1);
	}
	




XII. TYPES	
- Value(primitives): primitives are copied by their value
	+Number
	+String
	+Boolean
	+Symbol
	+undefined
	+null
-Reference (objects): objects are copied by their reference
	+Object
	+Function
	+Array




XIII. EVENT
- addEventListener() method:
,	+attaches event handler to specified element
	+multiple event handler/ same type event handler can be attached without overwriting each other
	+add to any DOM object not only HTML
- .addEventListener(event, function): set ups function whenver event delivered to target
- common target: element, document, window
- removeEventListener() method: 

- document.querySelector('.class'): look through html doc to find element with class name ...

*HTML events
- event = something browser/ user does
- onclick: 
	document.getElementById("myBtn").onclick = displayDate;

- onload and on unload event: triggers when user enters/ leaves the page, used to deal with cookies
onload used to check browser type and browser's version to load proper version
	<body onload="checkCookies()">

- onchange: used in combination w/ validation of input fields
when enter value -> unfocus by pressing TAB/ RETURN
	<input type="text" id="fname" onchange="upperCase()">
	upperCase() function is called input fields's content changes

- onmouseover and onmouseout: triggers mouse over/ out HTML element

- onmousedown, onmouseup, onclick:
- onfocus: 
- When use with JavaSript EventListener remove 'on'

- onkeypress, onkeydown, onkeyup: press key on keyboard
	onkeypress: not fired for (ALT, CTRL, SHIFT, ESC, etc)
	onkeydown: detect any key pressed


- don't direct call function, use call back
document.getElementById().addEventListener('click', function(){call back function()});

*3 WAYS TO ADD EVENTS
- method 1:
<button onclick="alert('Hello World')">Click Me</button>
 +less ideal, cluttering HTML, 1 "onclick" event per element

- method 2:
<!-- html file-->
<button id ="btn">Click Me</button>

//JavaScript file
const btn = document.querySelector('#btn');
btn.onclick = () => alert("Hello World");
 +DOM element can only have 1 "onclick" property

- method 3:
<!-- html file-->
<button id ="btn">Click Me Too</button>

//the Javascript file
const btn = document.querySelector('btn');
btn.addEventListener('click',() => {
  alert("Hello World");
});(

 +most flexible and powerful

- All 3 methods can be used with name functions:
<!-- html file -->
<!-- method 1 -->
<button onclick = "alertFunction> Click me baby</button>

//JavaScript file
function alertFunction(){
  alert("YAY! YOU DID IT!");
}

//method 2
btn.onclick = alertFunction;

//method 3
btn.addEventListener('click', alertFunction);

 +Name function clean up code, good for repeat function


*KEYCODE
- event.keycode / event.which: cross browser
- keycode() property: returns Unicode characters code 
	+character codes: ASCII character
	+Key codes: key number on keyboard
- Printable key (a-z, 1-9) use 'onkeypress' event
- Function key ("F1", "CAPS LOCK" or "Home" etc) use "onkeydown"/ "onkeyup"
- altKey, ctrlKey, metaKey, shiftKey: whether "ALT", "CONTROL", "META" or "SHIFT"
key was pressed

- fromCharCode() method: convert Unicode into character, return character
- charCode() /keyCode(): returns Unicode character code
- "string".charCodeAt(index): return unicode at specified index in a string


XIV. JAVASCRIPT DOM (Document Object Model)
- DOM: tree like representation contents on webpage/ document
- DOM: W3C (World Wide Web Consortium) standard for accessing documents
	3 different parts
	+Core DOM - Standard model for all document type 
	+XML DOM - 		"	   XML document
	+HTML DOM -		"	   HTML document

- Fundamental data type
	+Document:
	+Node: object within document, object can be element/text/attribute node
	+Element: refer element/ node of type element; one specific node
	+NodeList: array of elements, accessed by index in list item()/ list()
	+Attribute
	+NamedNodeMap



- JavaScript manipulate DOM/ changes what browser renders
- JavaScript run whenever <script> tag is encountered in HTML, if include at the top, DOM manipulation wil not work
because JS code being run before nodes are created in DOM.
==>Include JavaScript at the bottom of HTML file after DOM nodes are parsed and created
   
	OR use defer in script tag: execute JS after HTML DOM element loaded

	OR Use: document.addEventListener('DOMContentLoaded', () => {function}


*HTML DOM
- Object model + programming interface for HTML, 
standard how to get, change, add/ delete HTML elements
- defies:
	+HTML element as object
	+properties of all HTML element
	+method to access   "
	+events for	    "

- HTML DOM methods: action can perform
- HTML DOM properties: values of HTML elements that you can set/ change
- getElementById method: access HTML element through id of element
- innerHTML property: get/ replace content of element


*DOM METHOD
- Accessing document before accessing any elemnt in HTML page

- click(): simulate click event on HTML element

- document
	+finding HTML Elements:
		.getElementById(id)
		.getElementByTagName(name)
		.getElementByClassName(name)
	+query selector:
		.querySelector: look through html doc to find an elements with a certain class name/ ID
			.: look for class
			#: look for id
		.querySelectorAll: collect all elements that match a specified CSS selector (https://www.w3schools.com/cssref/css_selectors.asp)
		return NodeList object from this method
		if problem arise, convert Nodelist into array using Array.from(): collect elements into an array

	+change style with
		.getElementById(id).style.property = "new style"

	+Adding Events Handlers
		.getElementById(id).onclick = function(){code} - add event handler code to an onclick event


- Changing HTML elements
	         /.innerHTML = new html content inside {element}	//use sparringly due to security risk
		| .attribute = new value
		| .style.property = "new style" 	
		| .textContent = 'Hello World';		//create text node containning 'Hello world' and insert it into {element} 
	       /  
    {element}.<	
	       \	Editting attribute
		| .setAttribute(attribute, value) 	//if {attribute} exist updated it to {value} else create new {attribute} with {value}
		| .getAtrribute('id');  	//return value of specified attribute
		| .hasAttribute(name)		//check for existence
		\ .removeAttribute('id'); 	//remove specified attribute


- CSS Style Declaration: object represent collection CSS property-value pairs
	Properties: 	+cssText: sets/ return textual representation CSS declaration block
	E.g: element.style.cssText: return property
	     element.style.cssText = style: set property
			+length: return number of style declaration  	   '' 
			+parentRule: return CSS rule that is parent style block
	Mehod:
	+getPropertyPriority(): return if specified CSS property has "important!" priority set
		object.getPropertyPriority("propertyName");
	+getPropertyValue(): 	return value specified CSS property

	+item():		returns CSS property name from CSS declaration block, by index
		style.item(index);
	+removeProperty():	removes CSS property from CSS declaration block
	+setProperty():		sets new/ modifies existing CSS property CSS declaration block
		object.setProperty(propertyName, value, priority);
		object.setProperty("color", "blue", "important")		


- Method for working with text:text
	docment	.createTextNode: method creates Text node with specified text
+createElement -> createTextNode -> append/insertBefore createTextNode into new element
+useful when new element needed

		.innerHtml: return HTML content of an element
	       	.textContent: property sets/ returns text content of all elements in  specified node + all its descendants
+useful working existing element 
		.innerText: returns content of all elements except <script> and <style> elements

		.nodeValue: property return node value specified node, element node return null
+return null: document/ element node
+return value of attribute: attribute node
+return: content: text nodes/ comment nodes



- Working with classes
	+div.classList.add('new')	//add class 'new' to new div
	+div.classList.remove:		//remove class 'new' from div
	+div.classList.toggle: 		//add/ remove if element doesn't exist/ exist


- Adding and Deleting Elements
	document.createElement(element)		//create new element in memory for manipulation on styles/ attribute before placing on page	
      		.appendChild(element)		//places elements into DOM
		.insertBefore(newNod, referenceNode)	//add newNode before referenceNode
      parentNode.removeChild(element)	
		.replaceChild(element)
		.write(text)


- Adding innline style:
	div.style.color = 'blue';
	div.style.cssText = 'color: blue; background: white'; 
cssText: overwrite rules define in CSS
	div.setAttribute('style', 'color: blue; background: white');

	+style using CSS variable
	document.documentElement.style.cssText = "--cssVariable: red";
	document.documentElement.style.setProperty('--cssVariable', 'pink');
	document.documentElement.style.setAttribute("style", "--cssVariable: green");

- if accessing kebab-case Css rule from JS, either use camelCase/ bracket notation instead of dot notation
	div.style.background-color	//doesn't work - attempt to subtract color from background 
	div.style.backgroundColor	//accesses divs background-color style	
	div.style['background-color']	//also works
	div.style.cssText = "background-color: white"	//ok in string



- stopPropagation method: on event object, prevent handlers further up receiving event
	E.g: button inside clickable element, don't want click on button activate elements click


- Document.documentElement: return root element of document.
	E.g: HTML file root element would be <html>


- animation using javascript (https://www.w3schools.com/js/tryit.asp?filename=tryjs_dom_animate_3)
function myMove() {
  var elem = document.getElementById("animate");
  var pos = 0;
  var id = setInterval(frame, 5);
  function frame() {
    if (pos == 350) {
      clearInterval(id);
    } else {
      pos++;
      elem.style.top = pos + 'px';
      elem.style.left = pos + 'px';
    }
  }
}


*DOM NAVIGATION
<html>					<html> is the root node	
					<html> has no parents
  <head>				<html> is the parent of <head> and <body>
    <title>DOM Tutorial</title>		<head> is the first child of <html>
  </head>				<body> is the last child of <html>
					
  <body>				<head> has one child: <title>
    <h1>DOM Lesson one</h1>		<title> has one child (a text node): "DOM Tutorial"
    <p id="demo">Hello world!</p>	<body> has two children: <h1> and <p>
  </body>				<h1> has one child: "DOM Lesson one"
					<p> has one child: "Hello world!"
</html>					<h1> and <p> are siblings

- 3 diffrent ways to access an element value
	var paragraph = document.getElementById("demo").innerHTML;
	var paragraph = document.getElementById("demo").secondChild.nodeValue;
	var paragraph = document.getElementById("demo").childNode[1].nodeValue;
  		
- navigation between nodes:
	parentNode
	childNodes[nodenumber]
	firstChild
	lastChild
	nextSibling
	previousSibling

- DOM root nodes: 2 special properties to access full document
	+document.body - body of the document
	+document.documentElement - full document

- nodeName proterty of element node = tag name
		"      attribute node = attribute name
	nodeName of text node = #text
	nodeName of document node = #document

- nodeValue: value of node
- nodeType property: read only
	+ELEMENT_NODE	type	1	+COMMENT_NODE		8
	+ATTRIBUTE_NODE	 	2	+DOCUMENT_NODE		9
	+TEXT_NODE	 	3	+DOCUMENT_TYPE_NODE	10
	

*DOM NODES
- create new HTML elements (Nodes): add new element to HTML DOM must create the element
then append it to existing elemnet
	E.g:	<div id="div1">
		  <p id="p1">This is a paragraph.</p>
		  <p id="p2">This is another paragraph.</p>
		</div>

		<script>
		var para = document.createElement("p");
		var node = document.createTextNode("This is new.");
		para.appendChild(node);

		var element = document.getElementById("div1");
		element.appendChild(para);
		</script>
=> This is a paragraph
   This is another paragraph
   This is new

		var child = document.getElementById("p1");
		element.insertBefore(para, child);	
=> This is new
   This is a paragraph
   This is another paragraph
append add new element as last child while insertBefore can add in any position

- remove() method: find element to removed
does not work in older browsers
- removeChild() method: find parent node to remove element 
- replaceChild() method: replace an element to HTML DOM

+ HTML COLLECTION
- getElementByTagName() method returns an HTMLCollection object
- HTMLCollection object is an array-like list
- .length
- HTMLCollection is not an array, can loop through list + refer elements with number 
but can't use array methods like valueOf(), pop(), push(), join() on HTMLCollection
- Collection of HTML elements


* DOM NODELIST
- Nodelist: list/collection nodes extracted from document using querySelector
almost the same as HTMLCollection
- childNodes property return NodeList object

+Difference between HTMLCollection and a NodeList
	Similarities
- Both array-like list of objects
- .length property define number of item in the list
- Both provide index to access each item like array




		HTMLCollection				NodeList
-Collection of HTML elements			-Collection of document nodes
-can be access by name, id, index number		-can only be access by index number
						-can contain attribute node and text node

-live, changes in DOM automatically 		-static, changes in DOM does not affect content
updated		
						



- document.creatTextNode: creat text node
	+HTML include text + element node
	+use createElement to create element node
	+use element.appendChild or element.insertBefore to append text node

- innerHTML: sets/ returns HTML content of an element



*DOM WINDOWS
- prompt('text', 'default text'): prompt input box take user input






XV. CANVAS
- Canvas HTML element for graphics(drawing/ images etc) via scripting 
- Step by step:
1. Find canvas element
	var canvas=document.getElementById("myCanvas");
2. Create a drawing object
- getcontex() method: return drawing context on canvas
	var ctx = canvas.getContext(contextType);
	var ctx = canvas.getContext(contestType, contextAttribute); 
	+context Type: .2d: render  2 dimensions  opwn
		.webgl(experiemental webgl): 3 dimentional rendering context webgl version 1
		.webgl2: WebGL version 2
		.bitmapprerenderer: replace canvas content with ImageBitmap
3. Draw on canvas
- rect(x, y, width, height): creates rectangle
- fillRect(): filled rectangle
- strokeRect(): no fill rectangle
- clearRect(): clears specified pixels within rectangle
	x,y starting position
	rectangle width, height from starting point
- fillStyle before creat canvas
*Draw a line: 
	moveTo(x,y): define starting point
	lineTo(x,y): define end point
*Draw a circile:
	beginPath() - begin a path
	arc(x,y,r startangle. endgmae): create arc/ curve
		circle: startangle = 0, endangle = 2*Math.PI
		x,y: x,y circle center coordinate
		r: circle radius

* Gradient: fill canvas with gradient
	+createLinearGradient(x, y. x1. y1)
	+createRadicalGradient(x, y, r, x1, y1, r1)
- Add 2+ color stops
	+addColorStop(position, color)
		position = 0-1
- set fillStyle or strokeStyle to gradient
	ctx.fillStyle = grd;

*Draw Text
- .font:
- .fillText(text, x, y): draws "filled" text 
- .strokeText(text, x, y): draws text on a canvas
- .fillStyle: for color

*Draw images
-drawImage(image, x, y)





XVI. Javascript console
- String Interpolated: replacing placeholders with values in a string literal (backticks ``: template literal)
	const number = 42;
	const message = `the number is ${number};
	message; // `the number is 42`
- %c: put at the start of string for styling in console, 2nd arguement is for styling
	console.log('%c Hello World', 'font-sized: 20px; color: red; etc')
- console.:	warn:
		error: display error
		info: 
		assert (condition, action): check if things are true/ false, if false execute action
		clear:
		dir: view DOM element
		count: count number of times an element is iterated

- Grouping: group/ groupEnd to wrap element into group
group could be change to groupCollapse for better transparency		
	dogs.forEach(dog =>{
		console.group(`${dog.name}`)	
		console.log(`This is ${dog.nane}`);
		console.log(`${dog.name} is ${dog.age} years old`);
		console.log(`${dog.name} is $[dog.age * 7}dog years old`);

		console.groupEnd(`${dog.name}`)		
	})

- timing: time how much time an action cost
 
	console.time('fetching data`);		
	fetch('https://api.github.com//users/wesbro')
		.then(data => data.json())
		.then(data => {
			console.timeEnd('fetching data');
			console.log(data);
	})


- table: take array of objects, assuming same property -> display them in a table






XVI. TEST DRIVEN DEVELOPMENT (TDD)
- The practice of writiing automated tests, describe how code work before writing code
- require(): import code from javascript file
- describe(): body of the test, run and test code to see if output is correct
- it(): describe theoretical output in English, include expect() function
- module.export: put in javascript file to export and imported by require()
*Terminal
- jasmine File/directory: run TDD



	
XVII. REGULAR EXPRESSION
- Allow checking series of characters for 'matches'
a.k.a check form field to try and match valid email address
	must have '@' symbol or end with extension like .com, .org, .uk etc


- Creating regular expression: 
	+Using regexp literal (/.../)
	E.g: 	let re = /ab+c/;
	+Using constructor function of RegExp object:
	      	let re = new RegExp('ab+c');

- simple pattern: direct match
	/abc/ would match with "slabcraft" (abc) not "grab crab" (ab c)

- using special/meta characters: 
	Meta
	+\d: any digit character = [0-9]
	+\w: any word character = a-z, A-Z, 0-9 and '_''s(underscroe)
	+\s: white space character (spaces/ tabs etc)
	+\t: tab character only

	Special characters:
	+ (+): one or more quantifier
	+ \: escape character, escape default behaviour for special character
	+ [^]: negate symbol in charactor sect (caret char)
	+ []: character set
	+ '?': zero or one quantifier ( makes preceding char optional)
	+ '.': any char except newline char
	+ '*': 0-or-more quantifer (a bit like + but instead of one it's zero) 
	+ '|': or	
	+ (...): treat inside as seperate entity	
		E.g: (p|t)yre
		=> pyre, tyre - match	
	+ ?!: negative lookahead assertion
		E.g: /\d+(?!\.)/
		match number only if not followed by decimal 
	
- Unlimited repeat (+): E.g: [0-9]+
- Limited repeat({number}): 
	+E,g [0-9]{11} - 11 number
	+range of limited repeat: {acd, b}
		E.g: [a-z]{5, 8}
	+At least 5 repeats:
		E.g: [a-z] {5,}		



- Character set [...]: matches different characters in the same position in a word
	e.g: [ng]inja
		ninja -match, ginja - match, nginja -only 'ginja' match
		
	+exclude a chacracter: [^...]
		[^p]000: exclude any p in starting position	
		+a000, b000, 2000	- match
		-p000			- no match
	+range [...-...]: add hyphen in between
		[a-zA-Z]: match range a-z and A-Z

- Starting and ending patterns: ^...$
	E.g: ^[a-z]{5}$
	=> asdf - match
	=> asdfdag - no match has to be at beginning + end

- Flags:-i : case insensitive
	-g: global
	-m: multi-line search
	-s: allows . to match newline characters
	-u: "unicode"; treat a pattern as a sequence of unicode code points
	-y: perform a "sticky" search, matches starting at current position in target string

	re = /pattern/flags;
or	re = new RegExp('pattern', 'flags');

- email: 4 part:
	    1		2	    test3		4
	(yourName) @ (domain) . (extension) (.again)
1: any letters, numbers, dots +/ hyphens
2: any letters, numbers +/ hyphens
3: any letters
4: (.)dot then any letters


*RegExp METHOD
RegExp
- .exec(str): Execute search for match in string. Return array of info / null
- .test(str): Test match in string. Return true/false
- .match(regexp): Returns array containing all matches, capturing group/ null if no match
- .matchAll(regexp): Returns iterator containing all matches + capture groups
- .search(regexp): Test match in string. Returns index of match/ -1 if fails
- .replace(substr | regexp, newSubstr | function): Execute search match in string. Replace matched substring with replacement
if substr = string: only 1 instances
- .replaceAll(): Execute search all matches in string, replaces matched replacement substrings
- .split([seperator[, limit]]): Uses RexEx/ fixed string break string -> array substrings
	E.g: const myString = 'Hello 1 word. Sentence number 2."
	const: splits = myString.split(/(\d)/)
	console.log(splits);
	=> ['Hello ', '1', ' word . Sentence number ', '2', '.']
	\d any digits in 0-9 -> split at any number 


